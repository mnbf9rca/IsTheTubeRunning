/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/auth/ready': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Auth Readiness Check
     * @description Check if the authentication system is ready to accept logins.
     *
     *     This endpoint checks:
     *     - Database connectivity
     *     - Basic auth system health
     *
     *     Returns:
     *         Readiness status with optional message explaining any issues.
     *
     *     Note: This endpoint does NOT require authentication, as it's used by
     *     the frontend before the login flow begins.
     */
    get: operations['auth_readiness_check_api_v1_auth_ready_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/auth/me': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Current User Info
     * @description Get current authenticated user information.
     *
     *     This endpoint automatically creates a new user record on first
     *     authenticated request if the user doesn't exist in the database.
     *
     *     Returns:
     *         Current user information including internal ID, timestamps,
     *         and admin status. Does NOT include external_id or auth_provider
     *         for security.
     */
    get: operations['get_current_user_info_api_v1_auth_me_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/email': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Add Email
     * @description Add a new email address to the user's account.
     *
     *     The email will be added as unverified. Use the send-verification
     *     endpoint to send a verification code.
     *
     *     Args:
     *         request: Email address to add
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created email address
     *
     *     Raises:
     *         HTTPException: 409 if email already exists, 429 if rate limit exceeded
     */
    post: operations['add_email_api_v1_contacts_email_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/phone': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Add Phone
     * @description Add a new phone number to the user's account.
     *
     *     The phone will be added as unverified. Use the send-verification
     *     endpoint to send a verification code.
     *
     *     Args:
     *         request: Phone number to add (E.164 format recommended)
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created phone number
     *
     *     Raises:
     *         HTTPException: 409 if phone already exists, 429 if rate limit exceeded
     */
    post: operations['add_phone_api_v1_contacts_phone_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/{contact_id}/send-verification': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Send Verification
     * @description Send a verification code to an email or phone.
     *
     *     Rate limited to 3 requests per hour per contact.
     *
     *     Args:
     *         contact_id: UUID of the email or phone to verify
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Success response
     *
     *     Raises:
     *         HTTPException: 404 if contact not found, 429 if rate limit exceeded
     */
    post: operations['send_verification_api_v1_contacts__contact_id__send_verification_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/verify': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Verify Code
     * @description Verify a contact using a verification code.
     *
     *     Args:
     *         request: Verification code and contact ID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Success response
     *
     *     Raises:
     *         HTTPException: 400 if code is invalid/expired, 404 if contact not found
     */
    post: operations['verify_code_api_v1_contacts_verify_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * List Contacts
     * @description List all contacts (emails and phones) for the current user.
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         All user contacts with verification status
     */
    get: operations['list_contacts_api_v1_contacts_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/{contact_id}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    /**
     * Delete Contact
     * @description Delete an email or phone contact.
     *
     *     Args:
     *         contact_id: UUID of the contact to delete
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 404 if contact not found or doesn't belong to user
     */
    delete: operations['delete_contact_api_v1_contacts__contact_id__delete']
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/contacts/{contact_id}/primary': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    /**
     * Set Primary Contact
     * @description Set a contact as the primary contact.
     *
     *     Only verified contacts can be set as primary.
     *     Only one email and one phone can be primary at a time.
     *
     *     Args:
     *         contact_id: UUID of the contact to set as primary
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Updated contact
     *
     *     Raises:
     *         HTTPException: 404 if contact not found or doesn't belong to user,
     *                       400 if contact is not verified
     */
    patch: operations['set_primary_contact_api_v1_contacts__contact_id__primary_patch']
    trace?: never
  }
  '/api/v1/routes': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * List Routes
     * @description List all routes for the authenticated user.
     *
     *     Returns all routes (both active and inactive) with segment and schedule counts.
     *     The frontend can filter by active status if needed.
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of routes with counts
     */
    get: operations['list_routes_api_v1_routes_get']
    put?: never
    /**
     * Create Route
     * @description Create a new route.
     *
     *     Creates a route with no segments or schedules initially.
     *     Use the segments and schedules endpoints to add them after creation.
     *
     *     Args:
     *         request: UserRoute creation request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created route
     */
    post: operations['create_route_api_v1_routes_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/routes/disruptions': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Route Disruptions
     * @description Get current disruptions affecting user's routes.
     *
     *     Returns only disruptions affecting the authenticated user's routes.
     *     Uses cached TfL data (2-minute TTL) and station-level matching via
     *     UserRouteStationIndex for precision.
     *
     *     Args:
     *         active_only: If True, only check active routes. If False, check all routes.
     *             Defaults to True.
     *         current_user: Authenticated user (from JWT token)
     *         db: Database session
     *
     *     Returns:
     *         List of route disruptions with affected segments and stations.
     *         One entry per route-disruption pair (a route may appear multiple times
     *         if affected by multiple disruptions).
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_route_disruptions_api_v1_routes_disruptions_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/routes/{route_id}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Route
     * @description Get a route by ID with all segments and schedules.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Route with segments and schedules
     *
     *     Raises:
     *         HTTPException: 404 if route not found or doesn't belong to user
     */
    get: operations['get_route_api_v1_routes__route_id__get']
    put?: never
    post?: never
    /**
     * Delete Route
     * @description Delete a route.
     *
     *     This also deletes all associated segments and schedules (CASCADE).
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 404 if route not found or doesn't belong to user
     */
    delete: operations['delete_route_api_v1_routes__route_id__delete']
    options?: never
    head?: never
    /**
     * Update Route
     * @description Update route metadata (name, description, active status).
     *
     *     Only updates fields that are provided in the request.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         request: Update request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Updated route
     *
     *     Raises:
     *         HTTPException: 404 if route not found or doesn't belong to user
     */
    patch: operations['update_route_api_v1_routes__route_id__patch']
    trace?: never
  }
  '/api/v1/routes/{route_id}/segments': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    /**
     * Upsert Segments
     * @description Replace all segments for a route.
     *
     *     This validates the route before saving. If validation fails, no changes are made.
     *     Segments must be ordered with consecutive sequences starting from 0.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         request: Segments to set
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created segments
     *
     *     Raises:
     *         HTTPException: 404 if route not found, 400 if validation fails
     */
    put: operations['upsert_segments_api_v1_routes__route_id__segments_put']
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/routes/{route_id}/segments/{sequence}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    /**
     * Delete Segment
     * @description Delete a segment and resequence remaining segments.
     *
     *     Cannot delete if it would leave fewer than 2 segments.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         sequence: Segment sequence number (0-based)
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 404 if route or segment not found, 400 if would leave <2 segments
     */
    delete: operations['delete_segment_api_v1_routes__route_id__segments__sequence__delete']
    options?: never
    head?: never
    /**
     * Update Segment
     * @description Update a single segment.
     *
     *     This validates the entire route after the update. If validation fails,
     *     the update is rolled back.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         sequence: Segment sequence number (0-based)
     *         request: Update request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Updated segment
     *
     *     Raises:
     *         HTTPException: 404 if route or segment not found, 400 if validation fails
     */
    patch: operations['update_segment_api_v1_routes__route_id__segments__sequence__patch']
    trace?: never
  }
  '/api/v1/routes/{route_id}/schedules': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Create Schedule
     * @description Create a schedule for a route.
     *
     *     A route can have multiple schedules (e.g., different times for weekdays vs weekends).
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         request: Schedule creation request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created schedule
     *
     *     Raises:
     *         HTTPException: 404 if route not found
     */
    post: operations['create_schedule_api_v1_routes__route_id__schedules_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/routes/{route_id}/schedules/{schedule_id}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    /**
     * Delete Schedule
     * @description Delete a schedule.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         schedule_id: Schedule UUID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 404 if route or schedule not found
     */
    delete: operations['delete_schedule_api_v1_routes__route_id__schedules__schedule_id__delete']
    options?: never
    head?: never
    /**
     * Update Schedule
     * @description Update a schedule.
     *
     *     Only updates fields that are provided in the request.
     *
     *     Args:
     *         route_id: UserRoute UUID
     *         schedule_id: Schedule UUID
     *         request: Update request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Updated schedule
     *
     *     Raises:
     *         HTTPException: 404 if route or schedule not found, 400 if time validation fails
     */
    patch: operations['update_schedule_api_v1_routes__route_id__schedules__schedule_id__patch']
    trace?: never
  }
  '/api/v1/routes/{route_id}/notifications': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * List Notification Preferences
     * @description List all notification preferences for a route.
     *
     *     Args:
     *         route_id: Route UUID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of notification preferences
     *
     *     Raises:
     *         HTTPException: 404 if route not found or doesn't belong to user
     */
    get: operations['list_notification_preferences_api_v1_routes__route_id__notifications_get']
    put?: never
    /**
     * Create Notification Preference
     * @description Create a new notification preference for a route.
     *
     *     Args:
     *         route_id: Route UUID
     *         request: Notification preference creation request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Created notification preference
     *
     *     Raises:
     *         HTTPException: 400 (validation errors), 404 (route/contact not found),
     *                       409 (duplicate), 429 (rate limit)
     */
    post: operations['create_notification_preference_api_v1_routes__route_id__notifications_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/routes/{route_id}/notifications/{preference_id}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    post?: never
    /**
     * Delete Notification Preference
     * @description Delete a notification preference.
     *
     *     Args:
     *         route_id: Route UUID (validated against preference's route)
     *         preference_id: Preference UUID
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 400 (route mismatch), 404 (preference not found or doesn't belong to user)
     */
    delete: operations['delete_notification_preference_api_v1_routes__route_id__notifications__preference_id__delete']
    options?: never
    head?: never
    /**
     * Update Notification Preference
     * @description Update a notification preference.
     *
     *     Args:
     *         route_id: Route UUID (validated against preference's route)
     *         preference_id: Preference UUID
     *         request: Update request
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Updated notification preference
     *
     *     Raises:
     *         HTTPException: 400 (validation errors, route mismatch), 404 (preference/contact not found),
     *                       409 (duplicate)
     */
    patch: operations['update_notification_preference_api_v1_routes__route_id__notifications__preference_id__patch']
    trace?: never
  }
  '/api/v1/tfl/lines': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Lines
     * @description Get all tube lines.
     *
     *     Returns cached data from Redis or fetches from TfL API if cache expired.
     *     Data is cached for 24 hours (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of tube lines with metadata
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_lines_api_v1_tfl_lines_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/stations': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Stations
     * @description Get tube stations, optionally filtered by line and/or deduplicated by hub.
     *
     *     Returns cached data from Redis or database. Data is cached for 24 hours.
     *     Stations are populated by the admin-controlled /admin/tfl/build-graph endpoint.
     *
     *     When deduplicated=true, stations that share a hub_naptan_code are grouped into
     *     a single representative station with:
     *     - tfl_id: hub NaPTAN code (e.g., 'HUBSVS' instead of '940GZZLUSVS')
     *     - name: hub common name (e.g., 'Seven Sisters')
     *     - lines: aggregated from all hub child stations
     *
     *     Args:
     *         line_id: Optional TfL line ID to filter stations
     *         deduplicated: Whether to group hub stations into single entries (default: False)
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of stations with location and line information
     *
     *     Raises:
     *         HTTPException: 503 if TfL data not initialized (run /admin/tfl/build-graph)
     *         HTTPException: 404 if line_id provided but line doesn't exist
     *         HTTPException: 404 if line exists but no stations found
     *
     *     Examples:
     *         GET /tfl/stations  # All stations including hub children
     *         GET /tfl/stations?line_id=victoria  # Victoria line stations only
     *         GET /tfl/stations?deduplicated=true  # Hub-grouped stations
     *         GET /tfl/stations?line_id=victoria&deduplicated=true  # Victoria line, hub-grouped
     */
    get: operations['get_stations_api_v1_tfl_stations_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/disruptions': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Disruptions
     * @description Get current line-level disruptions across the tube network.
     *
     *     Returns disruptions affecting tube lines.
     *     Data is cached for 2 minutes (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of current line disruptions with severity and details
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_disruptions_api_v1_tfl_disruptions_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/validate-route': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Validate Route
     * @description Validate a multi-segment route.
     *
     *     Checks if valid connections exist between consecutive stations on the
     *     specified lines using the station connection graph. Uses BFS for pathfinding.
     *
     *     **Note**: Station connection graph must be built first using the admin
     *     endpoint POST /admin/tfl/build-graph.
     *
     *     Args:
     *         request: Route segments (ordered list of station + line pairs)
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Validation result with success status and helpful error messages
     *
     *     Raises:
     *         HTTPException: 500 if validation fails
     */
    post: operations['validate_route_api_v1_tfl_validate_route_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/network-graph': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Network Graph
     * @description Get the station network graph as an adjacency list.
     *
     *     This returns a mapping of station TfL IDs to their connected stations,
     *     which helps the frontend constrain user choices to valid next stations
     *     when building routes.
     *
     *     **Note**: Station connection graph must be built first using the admin
     *     endpoint POST /admin/tfl/build-graph.
     *
     *     Returns:
     *         Dictionary mapping station_tfl_id to list of connected stations with line info:
     *         ```json
     *         {
     *             "940GZZLUOXC": [
     *                 {
     *                     "station_id": "uuid",
     *                     "station_tfl_id": "940GZZLUBND",
     *                     "station_name": "Bond Street",
     *                     "line_id": "uuid",
     *                     "line_tfl_id": "central",
     *                     "line_name": "Central"
     *                 },
     *                 ...
     *             ]
     *         }
     *         ```
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Raises:
     *         HTTPException: 503 if graph hasn't been built yet, 500 if fetch fails
     */
    get: operations['get_network_graph_api_v1_tfl_network_graph_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/station-disruptions': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Station Disruptions
     * @description Get current station-level disruptions across the tube network.
     *
     *     Returns disruptions affecting specific stations (e.g., station closures,
     *     lift outages, etc.) as opposed to line-wide disruptions.
     *     Data is cached for 2 minutes (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of current station disruptions with details
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_station_disruptions_api_v1_tfl_station_disruptions_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/metadata/severity-codes': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Severity Codes
     * @description Get TfL severity code reference data.
     *
     *     Returns the list of severity codes and their descriptions from TfL API.
     *     Data is cached for 7 days (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of severity codes with levels and descriptions:
     *         ```json
     *         [
     *             {
     *                 "severity_level": 10,
     *                 "description": "Good Service",
     *                 "last_updated": "2025-01-01T00:00:00"
     *             },
     *             ...
     *         ]
     *         ```
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_severity_codes_api_v1_tfl_metadata_severity_codes_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/metadata/disruption-categories': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Disruption Categories
     * @description Get TfL disruption category reference data.
     *
     *     Returns the list of disruption categories from TfL API.
     *     Data is cached for 7 days (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of disruption categories with names and descriptions:
     *         ```json
     *         [
     *             {
     *                 "category_name": "PlannedWork",
     *                 "description": "Planned engineering work",
     *                 "last_updated": "2025-01-01T00:00:00"
     *             },
     *             ...
     *         ]
     *         ```
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_disruption_categories_api_v1_tfl_metadata_disruption_categories_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/metadata/stop-types': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Stop Types
     * @description Get TfL stop point type reference data.
     *
     *     Returns the list of relevant stop point types (filtered to
     *     NaptanMetroStation, NaptanRailStation, NaptanBusCoachStation).
     *     Data is cached for 7 days (or TTL specified by TfL API).
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of stop types with names and descriptions:
     *         ```json
     *         [
     *             {
     *                 "type_name": "NaptanMetroStation",
     *                 "description": "London Underground station",
     *                 "last_updated": "2025-01-01T00:00:00"
     *             },
     *             ...
     *         ]
     *         ```
     *
     *     Raises:
     *         HTTPException: 503 if TfL API is unavailable
     */
    get: operations['get_stop_types_api_v1_tfl_metadata_stop_types_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/lines/{line_id}/routes': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Line Routes
     * @description Get route variants for a specific line.
     *
     *     Returns ordered station sequences for each route variant on the line.
     *     This enables the frontend to show users only reachable stations on specific routes.
     *
     *     **Example**: For the Northern line, this returns separate routes for:
     *     - Edgware → Morden via Bank
     *     - High Barnet → Morden via Bank
     *     - Edgware → Morden via Charing Cross
     *     - etc.
     *
     *     **Note**: Route data must be built first using POST /admin/tfl/build-graph.
     *     Only "Regular" service routes are returned (Night services excluded for MVP).
     *
     *     Args:
     *         line_id: TfL line ID (e.g., "victoria", "northern", "elizabeth-line")
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Line route variants with ordered station lists
     *
     *     Raises:
     *         HTTPException: 404 if line not found, 503 if routes not built yet
     */
    get: operations['get_line_routes_api_v1_tfl_lines__line_id__routes_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/stations/{station_tfl_id}/routes': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Station Routes
     * @description Get all routes passing through a specific station.
     *
     *     Returns information about which line route variants serve this station.
     *
     *     **Example**: For Camden Town station, this returns routes from both:
     *     - Northern line (Edgware branch and High Barnet branch)
     *     - Including which direction each route travels
     *
     *     **Note**: Route data must be built first using POST /admin/tfl/build-graph.
     *     Only "Regular" service routes are returned (Night services excluded for MVP).
     *
     *     Args:
     *         station_tfl_id: TfL station ID (e.g., "940GZZLUCTN" for Camden Town)
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         Station route information showing all routes passing through this station
     *
     *     Raises:
     *         HTTPException: 404 if station not found, 503 if routes not built yet
     */
    get: operations['get_station_routes_api_v1_tfl_stations__station_tfl_id__routes_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/line-states': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Line States
     * @description Get current status of all lines.
     *
     *     Returns the current disruption/status information for all TfL lines.
     *     Useful for debugging and understanding which lines have alerts.
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of line states with current severity information
     */
    get: operations['get_line_states_api_v1_tfl_line_states_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/tfl/alert-config': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Alert Config
     * @description Get alert configuration showing which severities trigger alerts.
     *
     *     Returns a list of all severity codes with their alert enabled/disabled status.
     *     Severity codes are populated by syncing with the TfL API via POST /admin/tfl/sync-metadata.
     *
     *     Args:
     *         current_user: Authenticated user
     *         db: Database session
     *
     *     Returns:
     *         List of severity codes with their alert configuration
     */
    get: operations['get_alert_config_api_v1_tfl_alert_config_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/tfl/build-graph': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Build Tfl Graph
     * @description Build the station connection graph from TfL API data and trigger background index staleness detection.
     *
     *     This endpoint fetches station sequences for all tube lines and populates
     *     the StationConnection table with bidirectional connections. This is required
     *     for route validation.
     *
     *     After successfully building the graph, this endpoint queues a background task
     *     to detect and rebuild any route indexes that are now stale due to the TfL data update.
     *     The staleness detection runs asynchronously in a Celery worker and does not block this response.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Build statistics (lines, stations, connections count)
     *
     *     Raises:
     *         HTTPException: 403 if not admin, 503 if TfL API is unavailable, 500 if build fails
     */
    post: operations['build_tfl_graph_api_v1_admin_tfl_build_graph_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/tfl/sync-metadata': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Sync Tfl Metadata
     * @description Sync TfL metadata (severity codes, disruption categories, stop types) from TfL API.
     *
     *     This endpoint fetches reference data from TfL API and stores it in the database
     *     for use in disruption descriptions and frontend display. This should be run
     *     periodically to keep reference data up to date.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Sync statistics (counts of severity codes, disruption categories, stop types)
     *
     *     Raises:
     *         HTTPException: 403 if not admin, 503 if TfL API is unavailable, 500 if sync fails
     */
    post: operations['sync_tfl_metadata_api_v1_admin_tfl_sync_metadata_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/alerts/trigger-check': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Trigger Alert Check
     * @description Manually trigger an immediate disruption check for all active routes.
     *
     *     This endpoint bypasses the normal Celery schedule and runs the alert
     *     processing immediately. Useful for testing or forcing an update after
     *     known TfL issues.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Statistics about the alert check (routes checked, alerts sent, errors)
     *
     *     Raises:
     *         HTTPException: 403 if not admin, 500 if check fails
     */
    post: operations['trigger_alert_check_api_v1_admin_alerts_trigger_check_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/alerts/worker-status': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Worker Status
     * @description Check Celery worker health and status.
     *
     *     This endpoint inspects the Celery worker(s) to determine if they are
     *     running and processing tasks correctly. It tracks the worker's logical
     *     clock to detect if the worker is frozen (responding but not processing).
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *
     *     Returns:
     *         Worker status information (availability, active tasks, scheduled tasks)
     *
     *     Raises:
     *         HTTPException: 403 if not admin
     */
    get: operations['get_worker_status_api_v1_admin_alerts_worker_status_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/alerts/recent-logs': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Recent Notification Logs
     * @description Retrieve recent notification logs with pagination and filtering.
     *
     *     This endpoint returns notification logs in reverse chronological order
     *     (most recent first) with optional status filtering.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *         limit: Number of logs per page (1-1000, default 50)
     *         offset: Starting offset for pagination (default 0)
     *         status: Optional filter by notification status (sent/failed/pending)
     *
     *     Returns:
     *         Paginated list of notification logs with total count
     *
     *     Raises:
     *         HTTPException: 403 if not admin
     */
    get: operations['get_recent_notification_logs_api_v1_admin_alerts_recent_logs_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/users': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * List Users
     * @description List all users with pagination and optional search/filters.
     *
     *     This endpoint returns a paginated list of users, optionally filtered by
     *     search term (searches email and external_id) and deleted status.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *         limit: Number of users per page (1-1000, default 50)
     *         offset: Starting offset for pagination (default 0)
     *         search: Optional search term for email or external_id
     *         include_deleted: Whether to include soft-deleted users (default False)
     *
     *     Returns:
     *         Paginated list of users with email/phone contacts
     *
     *     Raises:
     *         HTTPException: 403 if not admin
     */
    get: operations['list_users_api_v1_admin_users_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/users/{user_id}': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get User Details
     * @description Get detailed information about a specific user.
     *
     *     This endpoint returns comprehensive user information including
     *     email addresses, phone numbers, and other profile details.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         user_id: UUID of the user to retrieve
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Detailed user information
     *
     *     Raises:
     *         HTTPException: 403 if not admin, 404 if user not found
     */
    get: operations['get_user_details_api_v1_admin_users__user_id__get']
    put?: never
    post?: never
    /**
     * Anonymise User
     * @description Anonymise a user by deleting PII and deactivating routes.
     *
     *     This is a privacy-focused deletion that implements data minimisation:
     *     - Deletes email addresses, phone numbers, verification codes (PII)
     *     - Anonymises external_id to "deleted_{user_id}"
     *     - Clears auth_provider
     *     - Deactivates all user routes (stops alerts)
     *     - Sets deleted_at timestamp
     *     - Preserves notification logs and route structure for analytics
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         user_id: UUID of the user to anonymise
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Confirmation of anonymisation
     *
     *     Raises:
     *         HTTPException: 403 if not admin, 404 if user not found, 400 if already deleted
     */
    delete: operations['anonymise_user_api_v1_admin_users__user_id__delete']
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/analytics/engagement': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Get Engagement Metrics
     * @description Get comprehensive engagement metrics for the admin dashboard.
     *
     *     This endpoint provides four categories of metrics:
     *     - **User Counts**: Total users, active users, verified contacts, admin users
     *     - **Route Statistics**: Total routes, active routes, average per user
     *     - **Notification Statistics**: Sent, failed, success rate, by method (last 30 days)
     *     - **Growth Metrics**: New users (7/30 days), daily signups (last 7 days)
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Comprehensive engagement metrics
     *
     *     Raises:
     *         HTTPException: 403 if not admin
     */
    get: operations['get_engagement_metrics_api_v1_admin_analytics_engagement_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/api/v1/admin/routes/rebuild-indexes': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get?: never
    put?: never
    /**
     * Rebuild Route Indexes
     * @description Rebuild route station indexes for single route or all routes.
     *
     *     Rebuilds the inverted index that maps (line_tfl_id, station_naptan) → route_id.
     *     This is useful after Line.route_variants data updates or for manual maintenance.
     *
     *     **Requires admin privileges.**
     *
     *     Args:
     *         route_id: Optional route UUID. If provided, rebuilds only that route. If None, rebuilds all routes.
     *         admin_user: Authenticated admin user
     *         db: Database session
     *
     *     Returns:
     *         Statistics about the rebuild operation. Individual route failures are reported
     *         in the errors list rather than raising exceptions.
     *
     *     Raises:
     *         HTTPException: 403 if not admin
     */
    post: operations['rebuild_route_indexes_api_v1_admin_routes_rebuild_indexes_post']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Root
     * @description Root endpoint.
     */
    get: operations['root__get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/health': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Health Check
     * @description Health check endpoint.
     */
    get: operations['health_check_health_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
  '/ready': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    /**
     * Readiness Check
     * @description Readiness check endpoint - verify dependencies.
     */
    get: operations['readiness_check_ready_get']
    put?: never
    post?: never
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
}
export type webhooks = Record<string, never>
export interface components {
  schemas: {
    /**
     * AddEmailRequest
     * @description Request to add a new email address.
     */
    AddEmailRequest: {
      /**
       * Email
       * Format: email
       */
      email: string
    }
    /**
     * AddPhoneRequest
     * @description Request to add a new phone number.
     */
    AddPhoneRequest: {
      /** Phone */
      phone: string
    }
    /**
     * AffectedRouteInfo
     * @description Route segment affected by disruption.
     *
     *     Contains affected stations for matching against user routes.
     *     Does NOT include route variant IDs (not available in Line.route_variants data).
     */
    AffectedRouteInfo: {
      /** Name */
      name: string
      /** Direction */
      direction: string
      /** Affected Stations */
      affected_stations: string[]
    }
    /**
     * AlertConfigResponse
     * @description Response schema for alert configuration per severity code.
     */
    AlertConfigResponse: {
      /**
       * Mode Id
       * @description Transport mode (e.g., 'tube', 'dlr')
       */
      mode_id: string
      /**
       * Severity Level
       * @description Severity level (0-20)
       */
      severity_level: number
      /**
       * Description
       * @description Description of severity level
       */
      description: string
      /**
       * Alerts Enabled
       * @description Whether alerts are enabled for this severity
       */
      alerts_enabled: boolean
    }
    /**
     * AnonymiseUserResponse
     * @description Response from user anonymisation.
     */
    AnonymiseUserResponse: {
      /**
       * Success
       * @description Whether anonymisation succeeded
       */
      success: boolean
      /**
       * Message
       * @description Human-readable result message
       */
      message: string
      /**
       * User Id
       * Format: uuid
       * @description ID of anonymised user
       */
      user_id: string
    }
    /**
     * AuthReadinessResponse
     * @description Auth system readiness check response.
     */
    AuthReadinessResponse: {
      /** Ready */
      ready: boolean
      /** Message */
      message?: string | null
    }
    /**
     * BuildGraphResponse
     * @description Response from building the station connection graph.
     */
    BuildGraphResponse: {
      /** Success */
      success: boolean
      /** Message */
      message: string
      /**
       * Lines Count
       * @description Number of lines processed
       */
      lines_count: number
      /**
       * Stations Count
       * @description Number of stations processed
       */
      stations_count: number
      /**
       * Connections Count
       * @description Number of connections created
       */
      connections_count: number
      /**
       * Hubs Count
       * @description Number of hub interchange stations
       */
      hubs_count: number
    }
    /**
     * ContactsResponse
     * @description Response containing all user contacts.
     */
    ContactsResponse: {
      /** Emails */
      emails: components['schemas']['EmailResponse'][]
      /** Phones */
      phones: components['schemas']['PhoneResponse'][]
    }
    /**
     * CreateNotificationPreferenceRequest
     * @description Request to create a new notification preference.
     */
    CreateNotificationPreferenceRequest: {
      method: components['schemas']['NotificationMethod']
      /** Target Email Id */
      target_email_id?: string | null
      /** Target Phone Id */
      target_phone_id?: string | null
    }
    /**
     * CreateUserRouteRequest
     * @description Request to create a new route.
     */
    CreateUserRouteRequest: {
      /**
       * Name
       * @description Route name
       */
      name: string
      /**
       * Description
       * @description Optional route description
       */
      description?: string | null
      /**
       * Active
       * @description Whether the route is active
       * @default true
       */
      active: boolean
      /**
       * Timezone
       * @description IANA timezone for schedule times (e.g., 'Europe/London', 'America/New_York')
       * @default Europe/London
       */
      timezone: string
    }
    /**
     * CreateUserRouteScheduleRequest
     * @description Request to create a schedule for a route.
     */
    CreateUserRouteScheduleRequest: {
      /**
       * Days Of Week
       * @description Days when route is active (e.g., ['MON', 'TUE', 'WED'])
       */
      days_of_week: string[]
      /**
       * Start Time
       * Format: time
       * @description Start time for monitoring in route's local timezone (naive time)
       */
      start_time: string
      /**
       * End Time
       * Format: time
       * @description End time for monitoring in route's local timezone (naive time)
       */
      end_time: string
    }
    /**
     * DailySignup
     * @description Daily signup count.
     */
    DailySignup: {
      /**
       * Date
       * @description Date in ISO format
       */
      date: string
      /**
       * Count
       * @description Number of signups on that day
       */
      count: number
    }
    /**
     * DisruptionCategoryResponse
     * @description Response schema for TfL disruption category metadata.
     */
    DisruptionCategoryResponse: {
      /**
       * Category Name
       * @description Category name
       */
      category_name: string
      /**
       * Description
       * @description Category description
       */
      description: string
      /**
       * Last Updated
       * Format: date-time
       * @description When this category was last updated
       */
      last_updated: string
    }
    /**
     * DisruptionResponse
     * @description Response schema for TfL disruption data.
     */
    DisruptionResponse: {
      /** Line Id */
      line_id: string
      /** Line Name */
      line_name: string
      /** Mode */
      mode: string
      /** Status Severity */
      status_severity: number
      /** Status Severity Description */
      status_severity_description: string
      /** Reason */
      reason?: string | null
      /** Created At */
      created_at?: string | null
      /** Affected Routes */
      affected_routes?: components['schemas']['AffectedRouteInfo'][] | null
    }
    /**
     * EmailAddressItem
     * @description Email address information.
     */
    EmailAddressItem: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Email */
      email: string
      /** Verified */
      verified: boolean
      /** Is Primary */
      is_primary: boolean
    }
    /**
     * EmailResponse
     * @description Email address response.
     */
    EmailResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Email */
      email: string
      /** Verified */
      verified: boolean
      /** Is Primary */
      is_primary: boolean
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
    }
    /**
     * EngagementMetrics
     * @description Comprehensive engagement metrics for admin dashboard.
     */
    EngagementMetrics: {
      user_counts: components['schemas']['UserCountMetrics']
      route_stats: components['schemas']['RouteStatMetrics']
      notification_stats: components['schemas']['NotificationStatMetrics']
      growth_metrics: components['schemas']['GrowthMetrics']
    }
    /**
     * GrowthMetrics
     * @description User growth and retention metrics.
     */
    GrowthMetrics: {
      /**
       * New Users Last 7 Days
       * @description New users in last 7 days
       */
      new_users_last_7_days: number
      /**
       * New Users Last 30 Days
       * @description New users in last 30 days
       */
      new_users_last_30_days: number
      /**
       * Daily Signups Last 7 Days
       * @description Daily signup counts for last 7 days
       */
      daily_signups_last_7_days: components['schemas']['DailySignup'][]
    }
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components['schemas']['ValidationError'][]
    }
    /**
     * LineResponse
     * @description Response schema for TfL line data.
     */
    LineResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Tfl Id */
      tfl_id: string
      /** Name */
      name: string
      /** Mode */
      mode: string
      route_variants?: components['schemas']['RoutesData'] | null
      /**
       * Last Updated
       * Format: date-time
       */
      last_updated: string
    }
    /**
     * LineRoutesResponse
     * @description Response schema for line route variants.
     */
    LineRoutesResponse: {
      /**
       * Line Tfl Id
       * @description TfL line ID (e.g., 'victoria')
       */
      line_tfl_id: string
      /**
       * Routes
       * @description List of route variants for this line
       */
      routes: components['schemas']['RouteVariant'][]
    }
    /**
     * LineStateResponse
     * @description Response schema for current line status.
     */
    LineStateResponse: {
      /**
       * Line Id
       * @description TfL line ID
       */
      line_id: string
      /**
       * Line Name
       * @description Line name
       */
      line_name: string
      /**
       * Mode
       * @description Transport mode
       */
      mode: string
      /**
       * Status Severity
       * @description Current severity level
       */
      status_severity: number
      /**
       * Status Severity Description
       * @description Current status description
       */
      status_severity_description: string
      /**
       * Reason
       * @description Disruption reason if any
       */
      reason?: string | null
    }
    /**
     * NetworkConnection
     * @description Connection information in the station network graph.
     *
     *     Represents a connection between two stations on a specific line,
     *     used for route validation and network visualization.
     */
    NetworkConnection: {
      /** Station Id */
      station_id: string
      /** Station Tfl Id */
      station_tfl_id: string
      /** Station Name */
      station_name: string
      /** Line Id */
      line_id: string
      /** Line Tfl Id */
      line_tfl_id: string
      /** Line Name */
      line_name: string
    }
    /**
     * NotificationLogItem
     * @description Individual notification log entry.
     */
    NotificationLogItem: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /**
       * User Id
       * Format: uuid
       */
      user_id: string
      /**
       * Route Id
       * Format: uuid
       */
      route_id: string
      /**
       * Sent At
       * Format: date-time
       */
      sent_at: string
      method: components['schemas']['NotificationMethod']
      status: components['schemas']['NotificationStatus']
      /** Error Message */
      error_message?: string | null
    }
    /**
     * NotificationMethod
     * @description Notification delivery method.
     * @enum {string}
     */
    NotificationMethod: 'email' | 'sms'
    /**
     * NotificationPreferenceResponse
     * @description Notification preference response.
     */
    NotificationPreferenceResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /**
       * Route Id
       * Format: uuid
       */
      route_id: string
      method: components['schemas']['NotificationMethod']
      /** Target Email Id */
      target_email_id: string | null
      /** Target Phone Id */
      target_phone_id: string | null
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string
    }
    /**
     * NotificationStatMetrics
     * @description Notification statistics metrics.
     */
    NotificationStatMetrics: {
      /**
       * Total Sent
       * @description Total notifications sent
       */
      total_sent: number
      /**
       * Successful
       * @description Successfully sent notifications
       */
      successful: number
      /**
       * Failed
       * @description Failed notifications
       */
      failed: number
      /**
       * Success Rate
       * @description Success rate percentage
       */
      success_rate: number
      /**
       * By Method Last 30 Days
       * @description Notification counts by method (last 30 days)
       */
      by_method_last_30_days: {
        [key: string]: number
      }
    }
    /**
     * NotificationStatus
     * @description Notification delivery status.
     * @enum {string}
     */
    NotificationStatus: 'sent' | 'failed' | 'pending'
    /**
     * PaginatedUsersResponse
     * @description Response from paginated user listing.
     */
    PaginatedUsersResponse: {
      /**
       * Total
       * @description Total number of users matching filter
       */
      total: number
      /**
       * Users
       * @description List of users
       */
      users: components['schemas']['UserListItem'][]
      /**
       * Limit
       * @description Number of users per page
       */
      limit: number
      /**
       * Offset
       * @description Starting offset for pagination
       */
      offset: number
    }
    /**
     * PhoneNumberItem
     * @description Phone number information.
     */
    PhoneNumberItem: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Phone */
      phone: string
      /** Verified */
      verified: boolean
      /** Is Primary */
      is_primary: boolean
    }
    /**
     * PhoneResponse
     * @description Phone number response.
     */
    PhoneResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Phone */
      phone: string
      /** Verified */
      verified: boolean
      /** Is Primary */
      is_primary: boolean
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
    }
    /**
     * RebuildIndexesResponse
     * @description Response from rebuilding route station indexes.
     */
    RebuildIndexesResponse: {
      /**
       * Success
       * @description Whether the rebuild completed successfully
       */
      success: boolean
      /**
       * Rebuilt Count
       * @description Number of routes rebuilt
       */
      rebuilt_count: number
      /**
       * Failed Count
       * @description Number of routes that failed to rebuild
       */
      failed_count: number
      /**
       * Errors
       * @description Error messages for failed routes
       */
      errors?: string[]
    }
    /**
     * RecentLogsResponse
     * @description Response from querying recent notification logs.
     */
    RecentLogsResponse: {
      /**
       * Total
       * @description Total number of logs matching filter
       */
      total: number
      /**
       * Logs
       * @description List of notification logs
       */
      logs: components['schemas']['NotificationLogItem'][]
      /**
       * Limit
       * @description Number of logs per page
       */
      limit: number
      /**
       * Offset
       * @description Starting offset for pagination
       */
      offset: number
    }
    /**
     * RouteDisruptionResponse
     * @description Response schema for route-specific disruptions.
     *
     *     Represents a disruption affecting a specific user route, with context
     *     about which segments and stations are affected.
     */
    RouteDisruptionResponse: {
      /**
       * Route Id
       * Format: uuid
       * @description ID of the affected route
       */
      route_id: string
      /**
       * Route Name
       * @description Name of the affected route
       */
      route_name: string
      /** @description Details of the TfL disruption */
      disruption: components['schemas']['DisruptionResponse']
      /**
       * Affected Segments
       * @description Segment sequence numbers affected by this disruption (e.g., [0, 1, 2])
       */
      affected_segments: number[]
      /**
       * Affected Stations
       * @description Station NaPTAN codes from this route that are affected
       */
      affected_stations: string[]
    }
    /**
     * RouteSegmentRequest
     * @description Single segment in a route (station + line).
     */
    RouteSegmentRequest: {
      /**
       * Station Tfl Id
       * @description TfL station ID (e.g., '940GZZLUOXC')
       */
      station_tfl_id: string
      /**
       * Line Tfl Id
       * @description TfL line ID (e.g., 'victoria', 'northern'). NULL means destination segment (no onward travel).
       */
      line_tfl_id?: string | null
    }
    /**
     * RouteStatMetrics
     * @description Route statistics metrics.
     */
    RouteStatMetrics: {
      /**
       * Total Routes
       * @description Total non-deleted routes
       */
      total_routes: number
      /**
       * Active Routes
       * @description Active routes
       */
      active_routes: number
      /**
       * Avg Routes Per User
       * @description Average routes per user
       */
      avg_routes_per_user: number
    }
    /**
     * RouteValidationRequest
     * @description Request to validate a multi-segment route.
     */
    RouteValidationRequest: {
      /**
       * Segments
       * @description Ordered list of stations and lines forming the route. Must have at least 2 segments (start and end stations).
       */
      segments: components['schemas']['RouteSegmentRequest'][]
    }
    /**
     * RouteValidationResponse
     * @description Response from route validation.
     */
    RouteValidationResponse: {
      /**
       * Valid
       * @description Whether the route is valid
       */
      valid: boolean
      /**
       * Message
       * @description Human-readable validation result
       */
      message: string
      /**
       * Invalid Segment Index
       * @description Index of the first invalid segment (0-based), if any
       */
      invalid_segment_index?: number | null
    }
    /**
     * RouteVariant
     * @description Schema for a single route variant (ordered station sequence).
     */
    RouteVariant: {
      /**
       * Name
       * @description Route name (e.g., 'Edgware → Morden via Bank')
       */
      name: string
      /**
       * Service Type
       * @description Service type (e.g., 'Regular', 'Night')
       */
      service_type: string
      /**
       * Direction
       * @description Direction: 'inbound' or 'outbound'
       */
      direction: string
      /**
       * Stations
       * @description Ordered list of TfL station IDs on this route variant
       */
      stations: string[]
    }
    /**
     * RouteVariantData
     * @description Route variant structure stored in database.
     */
    RouteVariantData: {
      /** Name */
      name?: string
      /** Service Type */
      service_type?: string
      /** Direction */
      direction?: string
      /** Stations */
      stations?: string[]
    }
    /**
     * RoutesData
     * @description Routes structure stored in Line.route_variants JSON field.
     */
    RoutesData: {
      /** Routes */
      routes?: components['schemas']['RouteVariantData'][]
    }
    /**
     * SendVerificationResponse
     * @description Response after sending verification code.
     */
    SendVerificationResponse: {
      /** Success */
      success: boolean
      /** Message */
      message: string
    }
    /**
     * SeverityCodeResponse
     * @description Response schema for TfL severity code metadata.
     */
    SeverityCodeResponse: {
      /**
       * Mode Id
       * @description Transport mode (e.g., 'tube', 'dlr')
       */
      mode_id: string
      /**
       * Severity Level
       * @description Severity level (0-20)
       */
      severity_level: number
      /**
       * Description
       * @description Description of severity level
       */
      description: string
      /**
       * Last Updated
       * Format: date-time
       * @description When this code was last updated
       */
      last_updated: string
    }
    /**
     * StationDisruptionResponse
     * @description Response schema for station disruption data.
     *
     *     Field names match TfL API DisruptedPoint structure (type, appearance).
     */
    StationDisruptionResponse: {
      /**
       * Station Id
       * Format: uuid
       */
      station_id: string
      /** Station Tfl Id */
      station_tfl_id: string
      /** Station Name */
      station_name: string
      /** Type */
      type?: string | null
      /** Description */
      description: string
      /** Appearance */
      appearance?: string | null
      /** Tfl Id */
      tfl_id: string
      /**
       * Created At Source
       * Format: date-time
       */
      created_at_source: string
      /** End Date */
      end_date?: string | null
    }
    /**
     * StationResponse
     * @description Response schema for TfL station data.
     */
    StationResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Tfl Id */
      tfl_id: string
      /** Name */
      name: string
      /** Latitude */
      latitude: number
      /** Longitude */
      longitude: number
      /** Lines */
      lines: string[]
      /**
       * Last Updated
       * Format: date-time
       */
      last_updated: string
      /** Hub Naptan Code */
      hub_naptan_code: string | null
      /** Hub Common Name */
      hub_common_name: string | null
    }
    /**
     * StationRouteInfo
     * @description Schema for route information for a station.
     */
    StationRouteInfo: {
      /**
       * Line Tfl Id
       * @description TfL line ID
       */
      line_tfl_id: string
      /**
       * Line Name
       * @description Line name
       */
      line_name: string
      /**
       * Route Name
       * @description Route variant name
       */
      route_name: string
      /**
       * Service Type
       * @description Service type
       */
      service_type: string
      /**
       * Direction
       * @description Direction
       */
      direction: string
    }
    /**
     * StationRoutesResponse
     * @description Response schema for routes passing through a station.
     */
    StationRoutesResponse: {
      /**
       * Station Tfl Id
       * @description TfL station ID
       */
      station_tfl_id: string
      /**
       * Station Name
       * @description Station name
       */
      station_name: string
      /**
       * Routes
       * @description Routes passing through this station
       */
      routes: components['schemas']['StationRouteInfo'][]
    }
    /**
     * StopTypeResponse
     * @description Response schema for TfL stop type metadata.
     */
    StopTypeResponse: {
      /**
       * Type Name
       * @description Stop type identifier
       */
      type_name: string
      /**
       * Description
       * @description Stop type description
       */
      description: string
      /**
       * Last Updated
       * Format: date-time
       * @description When this type was last updated
       */
      last_updated: string
    }
    /**
     * SyncMetadataResponse
     * @description Response from syncing TfL metadata tables.
     */
    SyncMetadataResponse: {
      /**
       * Success
       * @description Whether sync completed successfully
       */
      success: boolean
      /**
       * Message
       * @description Human-readable result message
       */
      message: string
      /**
       * Severity Codes Count
       * @description Number of severity codes synced
       */
      severity_codes_count: number
      /**
       * Disruption Categories Count
       * @description Number of disruption categories synced
       */
      disruption_categories_count: number
      /**
       * Stop Types Count
       * @description Number of stop types synced
       */
      stop_types_count: number
    }
    /**
     * TriggerCheckResponse
     * @description Response from manually triggering an alert check.
     */
    TriggerCheckResponse: {
      /**
       * Success
       * @description Whether the check completed successfully
       */
      success: boolean
      /**
       * Message
       * @description Human-readable result message
       */
      message: string
      /**
       * Routes Checked
       * @description Number of routes processed
       */
      routes_checked: number
      /**
       * Alerts Sent
       * @description Number of alerts sent
       */
      alerts_sent: number
      /**
       * Errors
       * @description Number of errors encountered
       */
      errors: number
    }
    /**
     * UpdateNotificationPreferenceRequest
     * @description Request to update a notification preference.
     */
    UpdateNotificationPreferenceRequest: {
      method?: components['schemas']['NotificationMethod'] | null
      /** Target Email Id */
      target_email_id?: string | null
      /** Target Phone Id */
      target_phone_id?: string | null
    }
    /**
     * UpdateUserRouteRequest
     * @description Request to update a route's metadata.
     */
    UpdateUserRouteRequest: {
      /** Name */
      name?: string | null
      /** Description */
      description?: string | null
      /** Active */
      active?: boolean | null
      /** Timezone */
      timezone?: string | null
    }
    /**
     * UpdateUserRouteScheduleRequest
     * @description Request to update a schedule.
     */
    UpdateUserRouteScheduleRequest: {
      /** Days Of Week */
      days_of_week?: string[] | null
      /** Start Time */
      start_time?: string | null
      /** End Time */
      end_time?: string | null
    }
    /**
     * UpdateUserRouteSegmentRequest
     * @description Request to update a single segment.
     */
    UpdateUserRouteSegmentRequest: {
      /** Station Tfl Id */
      station_tfl_id?: string | null
      /** Line Tfl Id */
      line_tfl_id?: string | null
    }
    /**
     * UpsertUserRouteSegmentsRequest
     * @description Request to replace all segments in a route.
     */
    UpsertUserRouteSegmentsRequest: {
      /**
       * Segments
       * @description Ordered list of segments. Must have at least 2 (start and end).
       */
      segments: components['schemas']['UserRouteSegmentRequest'][]
    }
    /**
     * UserCountMetrics
     * @description User count metrics.
     */
    UserCountMetrics: {
      /**
       * Total Users
       * @description Total non-deleted users
       */
      total_users: number
      /**
       * Active Users
       * @description Users with active routes
       */
      active_users: number
      /**
       * Users With Verified Email
       * @description Users with verified email
       */
      users_with_verified_email: number
      /**
       * Users With Verified Phone
       * @description Users with verified phone
       */
      users_with_verified_phone: number
      /**
       * Admin Users
       * @description Number of admin users
       */
      admin_users: number
    }
    /**
     * UserDetailResponse
     * @description Detailed user information.
     */
    UserDetailResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** External Id */
      external_id: string
      /** Auth Provider */
      auth_provider: string
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string
      /** Deleted At */
      deleted_at?: string | null
      /** Email Addresses */
      email_addresses?: components['schemas']['EmailAddressItem'][]
      /** Phone Numbers */
      phone_numbers?: components['schemas']['PhoneNumberItem'][]
    }
    /**
     * UserListItem
     * @description User item in list view.
     */
    UserListItem: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** External Id */
      external_id: string
      /** Auth Provider */
      auth_provider: string
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string
      /** Deleted At */
      deleted_at?: string | null
      /** Email Addresses */
      email_addresses?: components['schemas']['EmailAddressItem'][]
      /** Phone Numbers */
      phone_numbers?: components['schemas']['PhoneNumberItem'][]
    }
    /**
     * UserResponse
     * @description User information response.
     *
     *     Note: external_id and auth_provider are intentionally excluded
     *     for privacy and security reasons.
     */
    UserResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /**
       * Created At
       * Format: date-time
       */
      created_at: string
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string
      /** Is Admin */
      is_admin: boolean
    }
    /**
     * UserRouteListItemResponse
     * @description Simplified response schema for route listings.
     */
    UserRouteListItemResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Name */
      name: string
      /** Description */
      description: string | null
      /** Active */
      active: boolean
      /** Timezone */
      timezone: string
      /**
       * Segment Count
       * @description Number of segments in the route
       */
      segment_count: number
      /**
       * Schedule Count
       * @description Number of schedules for the route
       */
      schedule_count: number
    }
    /**
     * UserRouteResponse
     * @description Full response schema for a route with segments and schedules.
     */
    UserRouteResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Name */
      name: string
      /** Description */
      description: string | null
      /** Active */
      active: boolean
      /** Timezone */
      timezone: string
      /** Segments */
      segments: components['schemas']['UserRouteSegmentResponse'][]
      /** Schedules */
      schedules: components['schemas']['UserRouteScheduleResponse'][]
    }
    /**
     * UserRouteScheduleResponse
     * @description Response schema for a route schedule.
     */
    UserRouteScheduleResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Days Of Week */
      days_of_week: string[]
      /**
       * Start Time
       * Format: time
       */
      start_time: string
      /**
       * End Time
       * Format: time
       */
      end_time: string
    }
    /**
     * UserRouteSegmentRequest
     * @description Single segment in a route (station + line + sequence).
     */
    UserRouteSegmentRequest: {
      /**
       * Sequence
       * @description Order of this segment in the route (0-based)
       */
      sequence: number
      /**
       * Station Tfl Id
       * @description TfL station ID (e.g., '940GZZLUOXC') or hub NaPTAN code (e.g., 'HUBSVS'). Hub codes are resolved to specific stations using line context (Issue #65).
       */
      station_tfl_id: string
      /**
       * Line Tfl Id
       * @description TfL line ID (e.g., 'victoria', 'northern'). NULL for destination segment (no onward travel).
       */
      line_tfl_id?: string | null
    }
    /**
     * UserRouteSegmentResponse
     * @description Response schema for a route segment.
     */
    UserRouteSegmentResponse: {
      /**
       * Id
       * Format: uuid
       */
      id: string
      /** Sequence */
      sequence: number
      /** Station Tfl Id */
      station_tfl_id: string
      /** Line Tfl Id */
      line_tfl_id: string | null
    }
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[]
      /** Message */
      msg: string
      /** Error Type */
      type: string
    }
    /**
     * VerifyCodeRequest
     * @description Request to verify a code.
     */
    VerifyCodeRequest: {
      /**
       * Contact Id
       * Format: uuid
       */
      contact_id: string
      /** Code */
      code: string
    }
    /**
     * VerifyCodeResponse
     * @description Response after successful verification.
     */
    VerifyCodeResponse: {
      /** Success */
      success: boolean
      /** Message */
      message: string
    }
    /**
     * WorkerStatusResponse
     * @description Response from checking Celery worker status.
     */
    WorkerStatusResponse: {
      /**
       * Worker Available
       * @description Whether a worker is available
       */
      worker_available: boolean
      /**
       * Active Tasks
       * @description Number of currently executing tasks
       */
      active_tasks: number
      /**
       * Scheduled Tasks
       * @description Number of scheduled tasks
       */
      scheduled_tasks: number
      /**
       * Last Heartbeat
       * @description Timestamp of last worker heartbeat (if available)
       */
      last_heartbeat?: string | null
      /**
       * Message
       * @description Human-readable status message
       */
      message: string
    }
  }
  responses: never
  parameters: never
  requestBodies: never
  headers: never
  pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
  auth_readiness_check_api_v1_auth_ready_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['AuthReadinessResponse']
        }
      }
    }
  }
  get_current_user_info_api_v1_auth_me_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserResponse']
        }
      }
    }
  }
  add_email_api_v1_contacts_email_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['AddEmailRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['EmailResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  add_phone_api_v1_contacts_phone_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['AddPhoneRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['PhoneResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  send_verification_api_v1_contacts__contact_id__send_verification_post: {
    parameters: {
      query?: never
      header?: never
      path: {
        contact_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['SendVerificationResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  verify_code_api_v1_contacts_verify_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyCodeRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['VerifyCodeResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  list_contacts_api_v1_contacts_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['ContactsResponse']
        }
      }
    }
  }
  delete_contact_api_v1_contacts__contact_id__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        contact_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  set_primary_contact_api_v1_contacts__contact_id__primary_patch: {
    parameters: {
      query?: never
      header?: never
      path: {
        contact_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json':
            | components['schemas']['EmailResponse']
            | components['schemas']['PhoneResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  list_routes_api_v1_routes_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteListItemResponse'][]
        }
      }
    }
  }
  create_route_api_v1_routes_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateUserRouteRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_route_disruptions_api_v1_routes_disruptions_get: {
    parameters: {
      query?: {
        active_only?: boolean
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['RouteDisruptionResponse'][]
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_route_api_v1_routes__route_id__get: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  delete_route_api_v1_routes__route_id__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  update_route_api_v1_routes__route_id__patch: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateUserRouteRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  upsert_segments_api_v1_routes__route_id__segments_put: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['UpsertUserRouteSegmentsRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteSegmentResponse'][]
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  delete_segment_api_v1_routes__route_id__segments__sequence__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        sequence: number
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  update_segment_api_v1_routes__route_id__segments__sequence__patch: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        sequence: number
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateUserRouteSegmentRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteSegmentResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  create_schedule_api_v1_routes__route_id__schedules_post: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateUserRouteScheduleRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteScheduleResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  delete_schedule_api_v1_routes__route_id__schedules__schedule_id__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        schedule_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  update_schedule_api_v1_routes__route_id__schedules__schedule_id__patch: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        schedule_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateUserRouteScheduleRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserRouteScheduleResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  list_notification_preferences_api_v1_routes__route_id__notifications_get: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['NotificationPreferenceResponse'][]
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  create_notification_preference_api_v1_routes__route_id__notifications_post: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNotificationPreferenceRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      201: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['NotificationPreferenceResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  delete_notification_preference_api_v1_routes__route_id__notifications__preference_id__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        preference_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown
        }
        content?: never
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  update_notification_preference_api_v1_routes__route_id__notifications__preference_id__patch: {
    parameters: {
      query?: never
      header?: never
      path: {
        route_id: string
        preference_id: string
      }
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNotificationPreferenceRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['NotificationPreferenceResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_lines_api_v1_tfl_lines_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['LineResponse'][]
        }
      }
    }
  }
  get_stations_api_v1_tfl_stations_get: {
    parameters: {
      query?: {
        /** @description Filter stations by TfL line ID (e.g., 'victoria') */
        line_id?: string | null
        /** @description Group hub stations into single entries with aggregated lines (e.g., 'Seven Sisters' instead of separate Rail and Tube stations) */
        deduplicated?: boolean
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['StationResponse'][]
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_disruptions_api_v1_tfl_disruptions_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['DisruptionResponse'][]
        }
      }
    }
  }
  validate_route_api_v1_tfl_validate_route_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['RouteValidationRequest']
      }
    }
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['RouteValidationResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_network_graph_api_v1_tfl_network_graph_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': {
            [key: string]: components['schemas']['NetworkConnection'][]
          }
        }
      }
    }
  }
  get_station_disruptions_api_v1_tfl_station_disruptions_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['StationDisruptionResponse'][]
        }
      }
    }
  }
  get_severity_codes_api_v1_tfl_metadata_severity_codes_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['SeverityCodeResponse'][]
        }
      }
    }
  }
  get_disruption_categories_api_v1_tfl_metadata_disruption_categories_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['DisruptionCategoryResponse'][]
        }
      }
    }
  }
  get_stop_types_api_v1_tfl_metadata_stop_types_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['StopTypeResponse'][]
        }
      }
    }
  }
  get_line_routes_api_v1_tfl_lines__line_id__routes_get: {
    parameters: {
      query?: never
      header?: never
      path: {
        line_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['LineRoutesResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_station_routes_api_v1_tfl_stations__station_tfl_id__routes_get: {
    parameters: {
      query?: never
      header?: never
      path: {
        station_tfl_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['StationRoutesResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_line_states_api_v1_tfl_line_states_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['LineStateResponse'][]
        }
      }
    }
  }
  get_alert_config_api_v1_tfl_alert_config_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['AlertConfigResponse'][]
        }
      }
    }
  }
  build_tfl_graph_api_v1_admin_tfl_build_graph_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['BuildGraphResponse']
        }
      }
    }
  }
  sync_tfl_metadata_api_v1_admin_tfl_sync_metadata_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['SyncMetadataResponse']
        }
      }
    }
  }
  trigger_alert_check_api_v1_admin_alerts_trigger_check_post: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['TriggerCheckResponse']
        }
      }
    }
  }
  get_worker_status_api_v1_admin_alerts_worker_status_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['WorkerStatusResponse']
        }
      }
    }
  }
  get_recent_notification_logs_api_v1_admin_alerts_recent_logs_get: {
    parameters: {
      query?: {
        /** @description Number of logs to return */
        limit?: number
        /** @description Starting offset for pagination */
        offset?: number
        /** @description Filter by notification status */
        status?: components['schemas']['NotificationStatus'] | null
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['RecentLogsResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  list_users_api_v1_admin_users_get: {
    parameters: {
      query?: {
        /** @description Number of users to return */
        limit?: number
        /** @description Starting offset for pagination */
        offset?: number
        /** @description Search term (email or external_id) */
        search?: string | null
        /** @description Include soft-deleted users */
        include_deleted?: boolean
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['PaginatedUsersResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_user_details_api_v1_admin_users__user_id__get: {
    parameters: {
      query?: never
      header?: never
      path: {
        user_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['UserDetailResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  anonymise_user_api_v1_admin_users__user_id__delete: {
    parameters: {
      query?: never
      header?: never
      path: {
        user_id: string
      }
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['AnonymiseUserResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  get_engagement_metrics_api_v1_admin_analytics_engagement_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['EngagementMetrics']
        }
      }
    }
  }
  rebuild_route_indexes_api_v1_admin_routes_rebuild_indexes_post: {
    parameters: {
      query?: {
        route_id?: string | null
      }
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['RebuildIndexesResponse']
        }
      }
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': components['schemas']['HTTPValidationError']
        }
      }
    }
  }
  root__get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': {
            [key: string]: string
          }
        }
      }
    }
  }
  health_check_health_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': {
            [key: string]: string
          }
        }
      }
    }
  }
  readiness_check_ready_get: {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    requestBody?: never
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown
        }
        content: {
          'application/json': {
            [key: string]: string
          }
        }
      }
    }
  }
}
