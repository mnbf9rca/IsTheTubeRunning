# Architecture Decision Records (ADR)

This document captures key architectural decisions made during the development of the TfL Disruption Alert System.

Note: when running commands in /backend ALWAYS use `uv run` never naked `python`. Do not use pip.

---

## Key Architectural Decisions Made

1. **Monorepo**: Easier management for hobby project, shared types
2. **Auth0**: Offload auth complexity, focus on core features
3. **Multi-line routes**: More realistic commute scenarios
4. **Celery + Redis**: Proper async job handling for scalability
5. **Azure VM + Docker Compose**: Full control, cost-effective within free credits, no per-service pricing
6. **Cloudflare + UFW**: Free WAF, SSL, CDN; restrict access to Cloudflare IPs only
7. **SOPS/age + Docker secrets**: Self-contained secret management, no external service dependency
8. **shadcn/ui**: Lightweight, customizable, modern Tailwind-based components
9. **Code-based verification**: Consistent UX for email and SMS
10. **uv for Python**: Fast, modern package management
11. **Tailwind CSS v4**: Using latest v4 (not v3). Configuration and syntax differ significantly from v3. Use Context7 or WebFetch tools to get current v4 documentation when needed.
12. **UUIDs for Primary Keys**: Prevents enumeration attacks, better security for user data (Phase 2)
13. **Soft Deletes**: Audit trail and data recovery capability via deleted_at timestamp (Phase 2)
14. **JSON for Route Schedules**: PostgreSQL JSON support for days_of_week arrays (Phase 2)
15. **Required Config**: DATABASE_URL, REDIS_URL, ALLOWED_ORIGINS must be provided; no misleading defaults (Phase 2)
16. **DB Credential Separation**: App runs with limited DB permissions; migrations in separate CI/init container with admin access (Phase 2)
17. **python-dotenv-vault for Secrets**: Replaced SOPS/age with python-dotenv-vault for simpler encrypted secret management; locally managed (no cloud service), pre-commit hooks auto-rebuild .env.vault (Phase 2)
18. **Rate Limiting Strategy**: Two-tier rate limiting for security - verification codes (3/hour to prevent spam) and failed contact additions (5/24h to prevent enumeration attacks) (Phase 4)
19. **Simple Verification Codes**: Random 6-digit numeric codes instead of HOTP/TOTP for better email/SMS UX; industry standard for contact verification (Phase 4)
20. **Separate Verification Flow**: Users add contacts first, then explicitly request verification; provides better UX and allows batch contact addition (Phase 4)
21. **Test Database Setup**: pytest-postgresql automatically creates isolated test databases for each test with Alembic migrations. DO NOT manually create test databases or set DATABASE_URL in pytest commands - the test infrastructure handles this automatically via the `db_session` fixture in conftest.py (Phase 4)
22. **Test Authentication Pattern**: When testing authenticated endpoints, use `test_user` + `auth_headers_for_user` fixtures together. The `auth_headers_for_user` fixture generates a JWT token that matches the `test_user`'s external_id, ensuring test data and authenticated requests use the same user. DO NOT use `test_user` + `auth_headers` together as they create different users with mismatched external_ids (Phase 4)
23. **pydantic-tfl-api Integration**: The pydantic-tfl-api library is synchronous, so all TfL API calls are wrapped in `asyncio.get_running_loop().run_in_executor()` to maintain async compatibility. Client initialization uses `app_key` parameter (optional, for rate limit increase). Responses are either ApiError or success objects with `.content` attribute containing Pydantic models (Phase 5)
24. **Dynamic Cache TTL**: Cache TTL is extracted from TfL API `content_expires` field rather than hardcoded values, ensuring cache invalidation aligns with TfL's data freshness. Falls back to sensible defaults (24h for lines/stations, 2min for disruptions) when TfL doesn't provide expiry (Phase 5)
25. **Simplified Station Graph**: Graph building creates bidirectional connections between consecutive stations on each line as returned by TfL API. This is a simplified approach suitable for basic route validation; actual route sequences would provide more accuracy but require more complex TfL API integration (Phase 5)
26. **Admin Endpoint for Graph Building**: Station graph is built on-demand via admin endpoint rather than on startup to avoid blocking application initialization. Can be automated with Celery scheduler in Phase 8 (Phase 5)
27. **NullPool for Async Test Isolation**: Use `sqlalchemy.pool.NullPool` for database connections in test environments (app/core/database.py when DEBUG=true, tests/conftest.py for test fixtures). Prevents "Task attached to a different loop" errors when pytest-asyncio creates new event loops per test. This is the standard solution for async SQLAlchemy testing. Each database operation creates a fresh connection instead of pooling - acceptable performance trade-off for test reliability (Phase 5)
28. **Async Test Mocking Strategy**: Mock `asyncio.get_running_loop()` directly instead of mocking client classes in TfL service tests. Simpler approach that avoids freezegun async complications and is more explicit about async behavior. Pattern: `mock_loop = AsyncMock(); mock_loop.run_in_executor = AsyncMock(return_value=mock_response); mock_get_loop.return_value = mock_loop` (Phase 5)
29. **Test Database Dependency Override Pattern**: When creating fixtures that use `AsyncClient` with `ASGITransport(app=app)`, MUST override `app.dependency_overrides[get_db]` to use the test `db_session` fixture. This ensures the app uses the test database (with migrations run) instead of the production database URL from settings. Pattern: Import `get_db` from `app.core.database`, create override function `async def override_get_db() -> AsyncGenerator[AsyncSession]: yield db_session`, set `app.dependency_overrides[get_db] = override_get_db`, use try/finally to clear overrides. Without this, app code will attempt to connect to a non-existent or unmigrated database, causing "relation does not exist" errors. See test_auth_integration.py, test_contacts_api.py, and test_tfl_api.py for reference implementations (Phase 5)
30. **IntegrityError Recovery Test Pattern**: Tests that verify IntegrityError recovery (catching constraint violations, rolling back, and continuing with queries) require REAL database commits, not transaction-level commits. The standard `db_session` fixture (SAVEPOINT + listener) doesn't work because: (1) the sync listener conflicts with async rollback operations, and (2) rollback() would erase all test data including previously committed operations. Solution: Use `fresh_db_session` fixture which creates a new database per test with Alembic migrations. This is slower (~2s vs ~0.1s) but is the only pattern that supports testing real-world error recovery code paths. Currently used by 5 tests: race condition handling in user creation, duplicate email/phone detection with different casing/formatting. The `fresh_async_client` fixture pairs with `fresh_db_session` for API testing (Phase 5)
31. **Explicit Route Timezones**: Routes store an explicit timezone field (IANA format) to resolve timezone ambiguity for schedule times. Schedule start_time/end_time remain timezone-naive and are interpreted in the route's timezone. This allows DST to be handled naturally by Python's zoneinfo without requiring database updates during DST transitions. Default timezone is Europe/London for TfL use case. Pydantic validators ensure only valid IANA timezone names are accepted. This design is portable (supports future multi-city expansion), type-safe, and follows industry best practices. (Phase 6 refinement)
32. **Content-Based Alert Deduplication**: Track last alert state in Redis (key: `last_alert:{route_id}:{user_id}`) with SHA256 hash of disruption details (line_id, status_severity_description, reason). Only send new alert if content changed. Prevents spam while keeping users informed of status changes. TTL: 7 days for auto-cleanup. This approach avoids database writes for transient state and provides fast lookups. (Phase 8)
33. **Hybrid Task Scheduling**: Celery beat runs every 30s, but TfL data fetch respects cache layer TTL (typically 2min). Achieves dynamic scheduling without complex logic - responsive to cache expiry while minimizing redundant API calls. Task timeout: 5 min hard limit, 4 min soft limit to prevent runaway tasks. (Phase 8)
34. **Worker Database Sessions**: Celery workers use separate async SQLAlchemy engine/session factory from FastAPI app. Prevents connection pool conflicts and allows independent scaling. Uses NullPool in tests for isolation, QueuePool in production for connection reuse. Workers get sessions via `get_worker_session()` helper with proper cleanup. (Phase 8)
35. **Admin Role-Based Authorization**: Admin endpoints protected by `require_admin()` dependency that checks `admin_users` table. Two-tier auth: JWT validation (any authenticated user) → admin role check (403 if not admin). AdminUser model tracks role (admin/superadmin), granted_at, and granted_by for audit trail. Follows principle of least privilege. (Phase 8)
36. **Privacy-Focused User Deletion**: DELETE /admin/users/{id} implements GDPR-style data minimisation while preserving analytics capability. Deletes PII (email_addresses, phone_numbers, verification_codes), anonymises external_id to "deleted_{user_id}", clears auth_provider, deactivates all routes (stops alerts), sets deleted_at timestamp. Preserves notification_logs and route structure for aggregated analytics (user_id becomes anonymous identifier). Transaction-based to ensure atomicity. Deletion order: verification_codes → emails/phones → notification_preferences → route deactivation → user update. (Phase 9)
37. **KISS Analytics Approach**: Single comprehensive engagement endpoint (GET /admin/analytics/engagement) instead of multiple specialized analytics APIs. Returns four metric categories in one call: user counts, route stats, notification stats, growth/retention metrics. Can add specialized endpoints later if needed, but current approach reduces API surface area and simplifies frontend integration. Follows YAGNI principle. (Phase 9)
38. **Explicit NotificationPreference Deletion on Anonymization**: Explicitly delete NotificationPreference records during user anonymization rather than relying on implicit CASCADE behavior. Rationale: (1) Code clarity - makes deletion explicit for future maintainers, (2) KISS/YAGNI - no need for placeholder contacts or schema changes, (3) Data minimization - preference configurations (intent) without active users are not actionable, (4) Analytics sufficiency - NotificationLog preserves actual behavior data (what was sent, success rates) which is more valuable than configuration data (what was planned). Aligns with "reality over intent" principle for analytics. (Phase 9)
39. **Backend Availability First Pattern**: Frontend checks backend health (GET /api/v1/auth/ready) before attempting authentication to distinguish "backend unavailable" from "backend denies auth". Prevents confusing UX where users appear authenticated (via Auth0) but cannot access the app due to backend issues. ServiceUnavailable page shown when backend is down, with auto-retry every 10s via BackendAvailabilityContext. (Phase 10 PR2.5)
40. **Explicit Backend Validation in Callback**: Auth0 callback handler explicitly validates with backend instead of relying on automatic useEffect validation. Three-way error handling: (1) 401/403 → force Auth0 logout, (2) 500+ → show retry option, (3) network error → show retry option. Prevents infinite retry loops and provides clear user feedback. (Phase 10 PR2.5)
41. **Backend Auth as Single Source of Truth**: Frontend components use `isBackendAuthenticated` from BackendAuthContext instead of Auth0's `isAuthenticated` for authorization decisions. Auth0 provides identity, backend provides authorization. This ensures frontend cannot access protected routes when backend validation fails or backend is unavailable. (Phase 10 PR2.5)
42. **Intent Preservation on Auth Redirect**: ProtectedRoute passes intended route via location state when redirecting to login (`state={{ from: location.pathname }}`). Login component restores intended route after successful authentication. Improves UX by returning users to the page they originally tried to access instead of always redirecting to /dashboard. (Phase 10 PR2.5)
