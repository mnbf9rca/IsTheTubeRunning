"""Pydantic schemas for TfL API data."""

from datetime import datetime
from typing import TypedDict
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

## Note: These are application internal schemas, not direct TfL API schemas.
## TfL API schemas are sourced from the pydantic-tfl-api package and as
## they are autogenerated from the OpenAPI spec, considered authoritative.
## Where there is a mismatch or inconsistency, the pydantic-tfl-api
## package is the source of truth for TfL API data structures.

# ==================== Response Schemas ====================


class RouteVariantData(TypedDict, total=False):
    """Route variant structure stored in database."""

    name: str
    service_type: str
    direction: str
    stations: list[str]


class RoutesData(TypedDict, total=False):
    """Routes structure stored in Line.route_variants JSON field."""

    routes: list[RouteVariantData]


class LineResponse(BaseModel):
    """Response schema for TfL line data."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    tfl_id: str
    name: str
    mode: str  # Transport mode: "tube", "overground", "dlr", "elizabeth-line", etc.
    route_variants: RoutesData | None = None  # Route sequences for branch-aware validation
    last_updated: datetime


class StationResponse(BaseModel):
    """Response schema for TfL station data."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    tfl_id: str
    name: str
    latitude: float
    longitude: float
    lines: list[str]  # List of line TfL IDs (e.g., ["victoria", "northern"])
    last_updated: datetime
    hub_naptan_code: str | None  # TfL hub NaPTAN code (e.g., 'HUBSVS' for Seven Sisters)
    hub_common_name: str | None  # Hub common name (e.g., 'Seven Sisters')


class AffectedRouteInfo(BaseModel):
    """Route segment affected by disruption.

    Contains affected stations for matching against user routes.
    Does NOT include route variant IDs (not available in Line.route_variants data).
    """

    name: str  # e.g., "Cockfosters → Heathrow Terminal 5"
    direction: str  # "inbound" or "outbound"
    affected_stations: list[str]  # NaPTAN codes in sequence


class DisruptionResponse(BaseModel):
    """Response schema for TfL disruption data."""

    line_id: str  # TfL line ID
    line_name: str
    mode: str  # Transport mode (tube, dlr, overground, etc.)
    status_severity: int  # 0-20 (0=special service, 10=good service, 20=closed)
    status_severity_description: str  # e.g., "Good Service", "Severe Delays"
    reason: str | None = None  # Description of disruption
    created_at: datetime | None = None  # When disruption started (if available)
    affected_routes: list[AffectedRouteInfo] | None = None  # Affected route segments with station sequences


class StationDisruptionResponse(BaseModel):
    """Response schema for station disruption data.

    Field names match TfL API DisruptedPoint structure (type, appearance).
    """

    station_id: UUID  # Database station UUID
    station_tfl_id: str  # TfL station ID (ATCO code)
    station_name: str
    type: str | None = None  # Disruption type (e.g., 'Information', 'Interchange Message')
    description: str
    appearance: str | None = None  # Disruption status (e.g., 'PlannedWork', 'RealTime', 'Information')
    tfl_id: str  # Hash-based disruption identifier
    created_at_source: datetime  # Start date from TfL API 'fromDate'
    end_date: datetime | None = None  # End date from TfL API 'toDate'


class RouteVariant(BaseModel):
    """Schema for a single route variant (ordered station sequence)."""

    name: str = Field(..., description="Route name (e.g., 'Edgware → Morden via Bank')")
    service_type: str = Field(..., description="Service type (e.g., 'Regular', 'Night')")
    direction: str = Field(..., description="Direction: 'inbound' or 'outbound'")
    stations: list[str] = Field(
        ...,
        description="Ordered list of TfL station IDs on this route variant",
    )


class LineRoutesResponse(BaseModel):
    """Response schema for line route variants."""

    line_tfl_id: str = Field(..., description="TfL line ID (e.g., 'victoria')")
    routes: list[RouteVariant] = Field(
        ...,
        description="List of route variants for this line",
    )


class StationRouteInfo(BaseModel):
    """Schema for route information for a station."""

    line_tfl_id: str = Field(..., description="TfL line ID")
    line_name: str = Field(..., description="Line name")
    route_name: str = Field(..., description="Route variant name")
    service_type: str = Field(..., description="Service type")
    direction: str = Field(..., description="Direction")


class StationRoutesResponse(BaseModel):
    """Response schema for routes passing through a station."""

    station_tfl_id: str = Field(..., description="TfL station ID")
    station_name: str = Field(..., description="Station name")
    routes: list[StationRouteInfo] = Field(
        ...,
        description="Routes passing through this station",
    )


# ==================== Request Schemas ====================


class RouteSegmentRequest(BaseModel):
    """Single segment in a route (station + line)."""

    station_tfl_id: str = Field(..., description="TfL station ID (e.g., '940GZZLUOXC')")
    line_tfl_id: str | None = Field(
        None,
        description="TfL line ID (e.g., 'victoria', 'northern'). NULL means destination segment (no onward travel).",
    )


class RouteValidationRequest(BaseModel):
    """Request to validate a multi-segment route."""

    segments: list[RouteSegmentRequest] = Field(
        ...,
        min_length=2,
        description="Ordered list of stations and lines forming the route. "
        "Must have at least 2 segments (start and end stations).",
    )


class RouteValidationResponse(BaseModel):
    """Response from route validation."""

    valid: bool = Field(..., description="Whether the route is valid")
    message: str = Field(..., description="Human-readable validation result")
    invalid_segment_index: int | None = Field(
        None,
        description="Index of the first invalid segment (0-based), if any",
    )


# ==================== Admin Schemas ====================


class BuildGraphResponse(BaseModel):
    """Response from building the station connection graph."""

    success: bool
    message: str
    lines_count: int = Field(..., description="Number of lines processed")
    stations_count: int = Field(..., description="Number of stations processed")
    connections_count: int = Field(..., description="Number of connections created")
    hubs_count: int = Field(..., description="Number of hub interchange stations")


class SeverityCodeResponse(BaseModel):
    """Response schema for TfL severity code metadata."""

    model_config = ConfigDict(from_attributes=True)

    mode_id: str = Field(..., description="Transport mode (e.g., 'tube', 'dlr')")
    severity_level: int = Field(..., description="Severity level (0-20)")
    description: str = Field(..., description="Description of severity level")
    last_updated: datetime = Field(..., description="When this code was last updated")


class AlertConfigResponse(BaseModel):
    """Response schema for alert configuration per severity code."""

    mode_id: str = Field(..., description="Transport mode (e.g., 'tube', 'dlr')")
    severity_level: int = Field(..., description="Severity level (0-20)")
    description: str = Field(..., description="Description of severity level")
    alerts_enabled: bool = Field(..., description="Whether alerts are enabled for this severity")


class LineStateResponse(BaseModel):
    """Response schema for current line status."""

    line_id: str = Field(..., description="TfL line ID")
    line_name: str = Field(..., description="Line name")
    mode: str = Field(..., description="Transport mode")
    status_severity: int = Field(..., description="Current severity level")
    status_severity_description: str = Field(..., description="Current status description")
    reason: str | None = Field(None, description="Disruption reason if any")


class DisruptionCategoryResponse(BaseModel):
    """Response schema for TfL disruption category metadata."""

    model_config = ConfigDict(from_attributes=True)

    category_name: str = Field(..., description="Category name")
    description: str = Field(..., description="Category description")
    last_updated: datetime = Field(..., description="When this category was last updated")


class StopTypeResponse(BaseModel):
    """Response schema for TfL stop type metadata."""

    model_config = ConfigDict(from_attributes=True)

    type_name: str = Field(..., description="Stop type identifier")
    description: str = Field(..., description="Stop type description")
    last_updated: datetime = Field(..., description="When this type was last updated")
